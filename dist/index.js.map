{"version":3,"file":"index.js","sources":["../webpack://ksm-action/./lib/main.js","../webpack://ksm-action/./node_modules/@actions/core/lib/command.js","../webpack://ksm-action/./node_modules/@actions/core/lib/core.js","../webpack://ksm-action/./node_modules/@actions/core/lib/file-command.js","../webpack://ksm-action/./node_modules/@actions/core/lib/utils.js","../webpack://ksm-action/./node_modules/@keeper-security/secrets-manager-core/dist/index.cjs.js","../webpack://ksm-action/external \"crypto\"","../webpack://ksm-action/external \"fs\"","../webpack://ksm-action/external \"https\"","../webpack://ksm-action/external \"os\"","../webpack://ksm-action/external \"path\"","../webpack://ksm-action/webpack/bootstrap","../webpack://ksm-action/webpack/runtime/compat","../webpack://ksm-action/webpack/startup"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRecordUids = exports.parseSecretsInputs = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nconst fs = __importStar(require(\"fs\"));\nconst secrets_manager_core_1 = require(\"@keeper-security/secrets-manager-core\");\nvar DestinationType;\n(function (DestinationType) {\n    DestinationType[DestinationType[\"output\"] = 0] = \"output\";\n    DestinationType[DestinationType[\"environment\"] = 1] = \"environment\";\n    DestinationType[DestinationType[\"file\"] = 2] = \"file\";\n})(DestinationType || (DestinationType = {}));\nconst parseSecretsInputs = (inputs) => {\n    const results = [];\n    for (const input of inputs) {\n        const inputParts = input.replace(/\\s/g, '').split('>');\n        let destinationType = DestinationType.output;\n        let destination = inputParts[1];\n        if (destination.startsWith('env:')) {\n            destinationType = DestinationType.environment;\n            destination = destination.slice(4);\n        }\n        else if (destination.startsWith('file:')) {\n            destinationType = DestinationType.file;\n            destination = destination.slice(5);\n        }\n        if (inputParts[0].split('/')[1] === 'file') {\n            destinationType = DestinationType.file;\n        }\n        results.push({\n            notation: inputParts[0],\n            destination,\n            destinationType\n        });\n    }\n    return results;\n};\nexports.parseSecretsInputs = parseSecretsInputs;\nconst getRecordUids = (inputs) => {\n    const set = new Set();\n    for (const input of inputs) {\n        set.add(input.notation.split('/')[0]);\n    }\n    return Array.from(set);\n};\nexports.getRecordUids = getRecordUids;\nconst downloadSecretFile = (file, destination) => __awaiter(void 0, void 0, void 0, function* () {\n    const fileData = yield secrets_manager_core_1.downloadFile(file);\n    fs.writeFileSync(destination, fileData);\n});\nconst run = () => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const config = core.getInput('keeper-secret-config');\n        const inputs = exports.parseSecretsInputs(core.getMultilineInput('secrets'));\n        const secrets = yield secrets_manager_core_1.getSecrets({ storage: secrets_manager_core_1.loadJsonConfig(config) }, exports.getRecordUids(inputs));\n        for (const input of inputs) {\n            const secret = secrets_manager_core_1.getValue(secrets, input.notation);\n            core.setSecret(secret);\n            switch (input.destinationType) {\n                case DestinationType.output:\n                    core.setOutput(input.destination, secret);\n                    break;\n                case DestinationType.environment:\n                    core.exportVariable(input.destination, secret);\n                    break;\n                case DestinationType.file:\n                    yield downloadSecretFile(secret, input.destination);\n                    break;\n            }\n        }\n    }\n    catch (error) {\n        core.setFailed(error.message);\n    }\n});\nrun();\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    }\n    else {\n        command_1.issueCommand('set-env', { name }, convertedVal);\n    }\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    return inputs;\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n */\nfunction error(message) {\n    command_1.issue('error', message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds an warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n */\nfunction warning(message) {\n    command_1.issue('warning', message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', { name }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issueCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n//# sourceMappingURL=utils.js.map","/* Version: 16.0.16 - September 3, 2021 19:26:00 */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar https = require('https');\nvar crypto = require('crypto');\nvar fs = require('fs');\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n['default'] = e;\n    return Object.freeze(n);\n}\n\nvar fs__namespace = /*#__PURE__*/_interopNamespace(fs);\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nfunction connectPlatform(p) {\r\n    exports.platform = p;\r\n}\r\nexports.platform = void 0;\r\nconst loadJsonConfig = (config) => {\r\n    return inMemoryStorage(JSON.parse(config));\r\n};\r\nconst inMemoryStorage = (storage) => {\r\n    const getValue = (key) => {\r\n        const keyParts = key.split('/');\r\n        let obj = storage;\r\n        for (const part of keyParts) {\r\n            obj = obj[part];\r\n            if (!obj) {\r\n                return undefined;\r\n            }\r\n        }\r\n        return obj.toString();\r\n    };\r\n    const saveValue = (key, value) => {\r\n        const keyParts = key.split('/');\r\n        let obj = storage;\r\n        for (const part of keyParts.slice(0, -1)) {\r\n            if (!obj[part]) {\r\n                obj[part] = {};\r\n            }\r\n            obj = obj[part];\r\n        }\r\n        obj[keyParts.slice(-1)[0]] = value;\r\n    };\r\n    const clearValue = (key) => {\r\n        const keyParts = key.split('/');\r\n        let obj = storage;\r\n        for (const part of keyParts.slice(0, -1)) {\r\n            if (!obj[part]) {\r\n                obj[part] = {};\r\n            }\r\n            obj = obj[part];\r\n        }\r\n        delete obj[keyParts.slice(-1)[0]];\r\n    };\r\n    return {\r\n        getString: key => Promise.resolve(getValue(key)),\r\n        saveString: (key, value) => {\r\n            saveValue(key, value);\r\n            return Promise.resolve();\r\n        },\r\n        getBytes: key => {\r\n            const bytesString = getValue(key);\r\n            if (bytesString) {\r\n                return Promise.resolve(exports.platform.base64ToBytes(bytesString));\r\n            }\r\n            else {\r\n                return Promise.resolve(undefined);\r\n            }\r\n        },\r\n        saveBytes: (key, value) => {\r\n            const bytesString = exports.platform.bytesToBase64(value);\r\n            saveValue(key, bytesString);\r\n            return Promise.resolve();\r\n        },\r\n        delete: (key) => {\r\n            clearValue(key);\r\n            return Promise.resolve();\r\n        }\r\n    };\r\n};\n\nconst webSafe64 = (source) => source.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\r\nconst webSafe64ToRegular = (source) => source.replace(/-/g, '+').replace(/_/g, '/') + '=='.substring(0, (3 * source.length) % 4);\r\nconst webSafe64ToBytes = (source) => exports.platform.base64ToBytes(webSafe64ToRegular(source));\r\nconst webSafe64FromBytes = (source) => webSafe64(exports.platform.bytesToBase64(source));\r\n// extracts public raw from private key for prime256v1 curve in der/pkcs8\r\n// privateKey: key.slice(36, 68)\r\nconst privateDerToPublicRaw = (key) => key.slice(-65);\n\nconst bytesToBase64 = (data) => Buffer.from(data).toString('base64');\r\nconst base64ToBytes = (data) => Buffer.from(data, 'base64');\r\nconst bytesToString = (data) => Buffer.from(data).toString();\r\nconst stringToBytes = (data) => Buffer.from(data);\r\nconst getRandomBytes = (length) => crypto.randomBytes(length);\r\nconst keyCache = {};\r\nconst loadKey = (keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const cachedKey = keyCache[keyId];\r\n    if (cachedKey) {\r\n        return cachedKey;\r\n    }\r\n    const keyBytes = storage\r\n        ? yield storage.getBytes(keyId)\r\n        : undefined;\r\n    if (!keyBytes) {\r\n        throw new Error(`Unable to load the key ${keyId}`);\r\n    }\r\n    keyCache[keyId] = keyBytes;\r\n    return keyBytes;\r\n});\r\nconst generateKeeperKeyPair = () => __awaiter(void 0, void 0, void 0, function* () {\r\n    return new Promise((resolve, reject) => {\r\n        crypto.generateKeyPair('ec', {\r\n            namedCurve: 'prime256v1'\r\n        }, (err, publicKey, privateKey) => {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve(privateKey.export({\r\n                    format: 'der',\r\n                    type: 'pkcs8'\r\n                }));\r\n            }\r\n        });\r\n    });\r\n});\r\nconst generatePrivateKey = (keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const privateKeyDer = yield generateKeeperKeyPair();\r\n    keyCache[keyId] = privateKeyDer;\r\n    yield storage.saveBytes(keyId, privateKeyDer);\r\n});\r\nconst exportPublicKey = (keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const privateKeyDer = yield loadKey(keyId, storage);\r\n    return privateDerToPublicRaw(privateKeyDer);\r\n});\r\nconst sign = (data, keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const privateKeyDer = yield loadKey(keyId, storage);\r\n    const key = crypto.createPrivateKey({\r\n        key: Buffer.from(privateKeyDer),\r\n        format: 'der',\r\n        type: 'pkcs8',\r\n    });\r\n    const sign = crypto.createSign('SHA256');\r\n    sign.update(data);\r\n    const sig = sign.sign(key);\r\n    return Promise.resolve(sig);\r\n});\r\nconst importKey = (keyId, key, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    keyCache[keyId] = key;\r\n    if (storage) {\r\n        yield storage.saveBytes(keyId, key);\r\n    }\r\n});\r\nconst encrypt = (data, keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const key = yield loadKey(keyId, storage);\r\n    const iv = getRandomBytes(12);\r\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\r\n    const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\r\n    const tag = cipher.getAuthTag();\r\n    return Buffer.concat([iv, encrypted, tag]);\r\n});\r\nconst _encrypt = (data, key) => {\r\n    const iv = crypto.randomBytes(12);\r\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\r\n    const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\r\n    const tag = cipher.getAuthTag();\r\n    const result = Buffer.concat([iv, encrypted, tag]);\r\n    return Promise.resolve(result);\r\n};\r\nconst _decrypt = (data, key) => {\r\n    const iv = data.subarray(0, 12);\r\n    const encrypted = data.subarray(12, data.length - 16);\r\n    const tag = data.subarray(data.length - 16);\r\n    const cipher = crypto.createDecipheriv('aes-256-gcm', key, iv);\r\n    cipher.setAuthTag(tag);\r\n    return Promise.resolve(Buffer.concat([cipher.update(encrypted), cipher.final()]));\r\n};\r\nconst unwrap = (key, keyId, unwrappingKeyId, storage, memoryOnly) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const unwrappingKey = yield loadKey(unwrappingKeyId, storage);\r\n    const unwrappedKey = yield _decrypt(key, unwrappingKey);\r\n    keyCache[keyId] = unwrappedKey;\r\n    if (memoryOnly) {\r\n        return;\r\n    }\r\n    if (storage) {\r\n        yield storage.saveBytes(keyId, unwrappedKey);\r\n    }\r\n});\r\nconst decrypt = (data, keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const key = yield loadKey(keyId, storage);\r\n    return _decrypt(data, key);\r\n});\r\nfunction hash(data) {\r\n    const hash = crypto.createHmac('sha512', data).update('KEEPER_SECRETS_MANAGER_CLIENT_ID').digest();\r\n    return Promise.resolve(hash);\r\n}\r\nconst publicEncrypt = (data, key, id) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const ecdh = crypto.createECDH('prime256v1');\r\n    ecdh.generateKeys();\r\n    const ephemeralPublicKey = ecdh.getPublicKey();\r\n    const sharedSecret = ecdh.computeSecret(key);\r\n    const sharedSecretCombined = Buffer.concat([sharedSecret, id || new Uint8Array()]);\r\n    const symmetricKey = crypto.createHash('SHA256').update(sharedSecretCombined).digest();\r\n    const encryptedData = yield _encrypt(data, symmetricKey);\r\n    return Buffer.concat([ephemeralPublicKey, encryptedData]);\r\n});\r\nconst fetchData = (res, resolve) => {\r\n    const retVal = {\r\n        statusCode: res.statusCode,\r\n        headers: res.headers,\r\n        data: null\r\n    };\r\n    res.on('data', data => {\r\n        retVal.data = retVal.data\r\n            ? Buffer.concat([retVal.data, data])\r\n            : data;\r\n    });\r\n    res.on('end', () => {\r\n        resolve(retVal);\r\n    });\r\n};\r\nconst get = (url, headers) => new Promise((resolve, reject) => {\r\n    const get = https.request(url, {\r\n        method: 'get',\r\n        headers: Object.assign({ 'User-Agent': `Node/${process.version}` }, headers)\r\n    }, (res) => {\r\n        fetchData(res, resolve);\r\n    });\r\n    get.on('error', reject);\r\n    get.end();\r\n});\r\nconst post = (url, payload, headers, allowUnverifiedCertificate) => new Promise((resolve, reject) => {\r\n    const options = {\r\n        rejectUnauthorized: !allowUnverifiedCertificate\r\n    };\r\n    const post = https.request(url, Object.assign(Object.assign({ method: 'post' }, options), { headers: Object.assign({ 'Content-Type': 'application/octet-stream', 'Content-Length': payload.length, 'User-Agent': `Node/${process.version}` }, headers) }), (res) => {\r\n        fetchData(res, resolve);\r\n    });\r\n    post.on('error', reject);\r\n    post.write(payload);\r\n    post.end();\r\n});\r\nconst cleanKeyCache = () => {\r\n    for (const key in keyCache) {\r\n        delete keyCache[key];\r\n    }\r\n};\r\nconst nodePlatform = {\r\n    bytesToBase64: bytesToBase64,\r\n    base64ToBytes: base64ToBytes,\r\n    bytesToString: bytesToString,\r\n    stringToBytes: stringToBytes,\r\n    getRandomBytes: getRandomBytes,\r\n    generatePrivateKey: generatePrivateKey,\r\n    exportPublicKey: exportPublicKey,\r\n    importKey: importKey,\r\n    unwrap: unwrap,\r\n    encrypt: encrypt,\r\n    encryptWithKey: _encrypt,\r\n    decrypt: decrypt,\r\n    decryptWithKey: _decrypt,\r\n    hash: hash,\r\n    publicEncrypt: publicEncrypt,\r\n    sign: sign,\r\n    get: get,\r\n    post: post,\r\n    cleanKeyCache: cleanKeyCache\r\n};\n\nlet packageVersion = '16.0.16';\r\nconst KEY_HOSTNAME = 'hostname'; // base url for the Secrets Manager service\r\nconst KEY_SERVER_PUBIC_KEY_ID = 'serverPublicKeyId';\r\nconst KEY_CLIENT_ID = 'clientId';\r\nconst KEY_CLIENT_KEY = 'clientKey'; // The key that is used to identify the client before public key\r\nconst KEY_APP_KEY = 'appKey'; // The application key with which all secrets are encrypted\r\nconst KEY_PRIVATE_KEY = 'privateKey'; // The client's private key\r\nconst CLIENT_ID_HASH_TAG = 'KEEPER_SECRETS_MANAGER_CLIENT_ID'; // Tag for hashing the client key to client id\r\nlet keeperPublicKeys;\r\nconst initialize = (pkgVersion) => {\r\n    if (pkgVersion) {\r\n        packageVersion = pkgVersion;\r\n    }\r\n    let keyNumber = 7;\r\n    keeperPublicKeys = [\r\n        'BK9w6TZFxE6nFNbMfIpULCup2a8xc6w2tUTABjxny7yFmxW0dAEojwC6j6zb5nTlmb1dAx8nwo3qF7RPYGmloRM',\r\n        'BKnhy0obglZJK-igwthNLdknoSXRrGB-mvFRzyb_L-DKKefWjYdFD2888qN1ROczz4n3keYSfKz9Koj90Z6w_tQ',\r\n        'BAsPQdCpLIGXdWNLdAwx-3J5lNqUtKbaOMV56hUj8VzxE2USLHuHHuKDeno0ymJt-acxWV1xPlBfNUShhRTR77g',\r\n        'BNYIh_Sv03nRZUUJveE8d2mxKLIDXv654UbshaItHrCJhd6cT7pdZ_XwbdyxAOCWMkBb9AZ4t1XRCsM8-wkEBRg',\r\n        'BA6uNfeYSvqagwu4TOY6wFK4JyU5C200vJna0lH4PJ-SzGVXej8l9dElyQ58_ljfPs5Rq6zVVXpdDe8A7Y3WRhk',\r\n        'BMjTIlXfohI8TDymsHxo0DqYysCy7yZGJ80WhgOBR4QUd6LBDA6-_318a-jCGW96zxXKMm8clDTKpE8w75KG-FY',\r\n        'BJBDU1P1H21IwIdT2brKkPqbQR0Zl0TIHf7Bz_OO9jaNgIwydMkxt4GpBmkYoprZ_DHUGOrno2faB7pmTR7HhuI',\r\n        'BJFF8j-dH7pDEw_U347w2CBM6xYM8Dk5fPPAktjib-opOqzvvbsER-WDHM4ONCSBf9O_obAHzCyygxmtpktDuiE',\r\n        'BDKyWBvLbyZ-jMueORl3JwJnnEpCiZdN7yUvT0vOyjwpPBCDf6zfL4RWzvSkhAAFnwOni_1tQSl8dfXHbXqXsQ8',\r\n        'BDXyZZnrl0tc2jdC5I61JjwkjK2kr7uet9tZjt8StTiJTAQQmnVOYBgbtP08PWDbecxnHghx3kJ8QXq1XE68y8c',\r\n        'BFX68cb97m9_sweGdOVavFM3j5ot6gveg6xT4BtGahfGhKib-zdZyO9pwvv1cBda9ahkSzo1BQ4NVXp9qRyqVGU'\r\n    ].reduce((keys, key) => {\r\n        keys[keyNumber++] = webSafe64ToBytes(key);\r\n        return keys;\r\n    }, {});\r\n};\r\nconst prepareGetPayload = (storage, recordsFilter) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const clientId = yield storage.getString(KEY_CLIENT_ID);\r\n    if (!clientId) {\r\n        throw new Error('Client Id is missing from the configuration');\r\n    }\r\n    const payload = {\r\n        clientVersion: 'ms' + packageVersion,\r\n        clientId: clientId\r\n    };\r\n    const appKey = yield storage.getBytes(KEY_APP_KEY);\r\n    if (!appKey) {\r\n        const publicKey = yield exports.platform.exportPublicKey(KEY_PRIVATE_KEY, storage);\r\n        payload.publicKey = exports.platform.bytesToBase64(publicKey);\r\n    }\r\n    if (recordsFilter) {\r\n        payload.requestedRecords = recordsFilter;\r\n    }\r\n    return payload;\r\n});\r\nconst prepareUpdatePayload = (storage, record) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const clientId = yield storage.getString(KEY_CLIENT_ID);\r\n    if (!clientId) {\r\n        throw new Error('Client Id is missing from the configuration');\r\n    }\r\n    const recordBytes = exports.platform.stringToBytes(JSON.stringify(record.data));\r\n    const encryptedRecord = yield exports.platform.encrypt(recordBytes, record.recordUid);\r\n    return {\r\n        clientVersion: 'ms' + packageVersion,\r\n        clientId: clientId,\r\n        recordUid: record.recordUid,\r\n        data: webSafe64FromBytes(encryptedRecord),\r\n        revision: record.revision\r\n    };\r\n});\r\nconst postFunction = (url, transmissionKey, payload, allowUnverifiedCertificate) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return exports.platform.post(url, payload.payload, {\r\n        PublicKeyId: transmissionKey.publicKeyId.toString(),\r\n        TransmissionKey: exports.platform.bytesToBase64(transmissionKey.encryptedKey),\r\n        Authorization: `Signature ${exports.platform.bytesToBase64(payload.signature)}`\r\n    }, allowUnverifiedCertificate);\r\n});\r\nconst generateTransmissionKey = (storage) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const transmissionKey = exports.platform.getRandomBytes(32);\r\n    const keyNumberString = yield storage.getString(KEY_SERVER_PUBIC_KEY_ID);\r\n    const keyNumber = keyNumberString ? Number(keyNumberString) : 7;\r\n    const keeperPublicKey = keeperPublicKeys[keyNumber];\r\n    if (!keeperPublicKey) {\r\n        throw new Error(`Key number ${keyNumber} is not supported`);\r\n    }\r\n    const encryptedKey = yield exports.platform.publicEncrypt(transmissionKey, keeperPublicKeys[keyNumber]);\r\n    return {\r\n        publicKeyId: keyNumber,\r\n        key: transmissionKey,\r\n        encryptedKey: encryptedKey\r\n    };\r\n});\r\nconst encryptAndSignPayload = (storage, transmissionKey, payload) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const payloadBytes = exports.platform.stringToBytes(JSON.stringify(payload));\r\n    const encryptedPayload = yield exports.platform.encryptWithKey(payloadBytes, transmissionKey.key);\r\n    const signatureBase = Uint8Array.of(...transmissionKey.encryptedKey, ...encryptedPayload);\r\n    const signature = yield exports.platform.sign(signatureBase, KEY_PRIVATE_KEY, storage);\r\n    return { payload: encryptedPayload, signature };\r\n});\r\nconst postQuery = (options, path, payload) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const hostName = yield options.storage.getString(KEY_HOSTNAME);\r\n    if (!hostName) {\r\n        throw new Error('hostname is missing from the configuration');\r\n    }\r\n    const url = `https://${hostName}/api/rest/sm/v1/${path}`;\r\n    while (true) {\r\n        const transmissionKey = yield generateTransmissionKey(options.storage);\r\n        const encryptedPayload = yield encryptAndSignPayload(options.storage, transmissionKey, payload);\r\n        const response = yield (options.queryFunction || postFunction)(url, transmissionKey, encryptedPayload, options.allowUnverifiedCertificate);\r\n        if (response.statusCode !== 200) {\r\n            const errorMessage = exports.platform.bytesToString(response.data.slice(0, 1000));\r\n            try {\r\n                const errorObj = JSON.parse(errorMessage);\r\n                if (errorObj.error === 'key') {\r\n                    yield options.storage.saveString(KEY_SERVER_PUBIC_KEY_ID, errorObj.key_id.toString());\r\n                    continue;\r\n                }\r\n            }\r\n            catch (_a) {\r\n            }\r\n            throw new Error(errorMessage);\r\n        }\r\n        return response.data\r\n            ? exports.platform.decryptWithKey(response.data, transmissionKey.key)\r\n            : new Uint8Array();\r\n    }\r\n});\r\nconst decryptRecord = (record) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const decryptedRecord = yield exports.platform.decrypt(exports.platform.base64ToBytes(record.data), record.recordUid);\r\n    const keeperRecord = {\r\n        recordUid: record.recordUid,\r\n        data: JSON.parse(exports.platform.bytesToString(decryptedRecord)),\r\n        revision: record.revision\r\n    };\r\n    if (record.files) {\r\n        keeperRecord.files = [];\r\n        for (const file of record.files) {\r\n            yield exports.platform.unwrap(exports.platform.base64ToBytes(file.fileKey), file.fileUid, record.recordUid);\r\n            const decryptedFile = yield exports.platform.decrypt(exports.platform.base64ToBytes(file.data), file.fileUid);\r\n            keeperRecord.files.push({\r\n                fileUid: file.fileUid,\r\n                data: JSON.parse(exports.platform.bytesToString(decryptedFile)),\r\n                url: file.url,\r\n                thumbnailUrl: file.thumbnailUrl\r\n            });\r\n        }\r\n    }\r\n    return keeperRecord;\r\n});\r\nconst fetchAndDecryptSecrets = (options, recordsFilter) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const storage = options.storage;\r\n    const payload = yield prepareGetPayload(storage, recordsFilter);\r\n    const responseData = yield postQuery(options, 'get_secret', payload);\r\n    const response = JSON.parse(exports.platform.bytesToString(responseData));\r\n    const records = [];\r\n    let justBound = false;\r\n    if (response.encryptedAppKey) {\r\n        justBound = true;\r\n        yield exports.platform.unwrap(exports.platform.base64ToBytes(response.encryptedAppKey), KEY_APP_KEY, KEY_CLIENT_KEY, storage);\r\n        yield storage.delete(KEY_CLIENT_KEY);\r\n    }\r\n    if (response.records) {\r\n        for (const record of response.records) {\r\n            yield exports.platform.unwrap(exports.platform.base64ToBytes(record.recordKey), record.recordUid, KEY_APP_KEY, storage, true);\r\n            const decryptedRecord = yield decryptRecord(record);\r\n            records.push(decryptedRecord);\r\n        }\r\n    }\r\n    if (response.folders) {\r\n        for (const folder of response.folders) {\r\n            yield exports.platform.unwrap(exports.platform.base64ToBytes(folder.folderKey), folder.folderUid, KEY_APP_KEY, storage, true);\r\n            for (const record of folder.records) {\r\n                yield exports.platform.unwrap(exports.platform.base64ToBytes(record.recordKey), record.recordUid, folder.folderUid);\r\n                const decryptedRecord = yield decryptRecord(record);\r\n                decryptedRecord.folderUid = folder.folderUid;\r\n                records.push(decryptedRecord);\r\n            }\r\n        }\r\n    }\r\n    const secrets = {\r\n        records: records\r\n    };\r\n    return { secrets, justBound };\r\n});\r\nconst getClientId = (clientKey) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const clientKeyHash = yield exports.platform.hash(webSafe64ToBytes(clientKey), CLIENT_ID_HASH_TAG);\r\n    return exports.platform.bytesToBase64(clientKeyHash);\r\n});\r\nconst initializeStorage = (storage, clientKey, hostName) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const clientKeyBytes = webSafe64ToBytes(clientKey);\r\n    const clientKeyHash = yield exports.platform.hash(clientKeyBytes, CLIENT_ID_HASH_TAG);\r\n    const clientId = exports.platform.bytesToBase64(clientKeyHash);\r\n    const existingClientId = yield storage.getString(KEY_CLIENT_ID);\r\n    if (existingClientId) {\r\n        if (existingClientId === clientId) {\r\n            return; // the storage is already initialized\r\n        }\r\n        throw new Error(`The storage is already initialized with a different client Id (${existingClientId})`);\r\n    }\r\n    yield storage.saveString(KEY_HOSTNAME, hostName);\r\n    yield storage.saveString(KEY_CLIENT_ID, clientId);\r\n    yield exports.platform.importKey(KEY_CLIENT_KEY, clientKeyBytes, storage);\r\n    yield exports.platform.generatePrivateKey(KEY_PRIVATE_KEY, storage);\r\n});\r\nconst getSecrets = (options, recordsFilter) => __awaiter(void 0, void 0, void 0, function* () {\r\n    exports.platform.cleanKeyCache();\r\n    const { secrets, justBound } = yield fetchAndDecryptSecrets(options, recordsFilter);\r\n    if (justBound) {\r\n        try {\r\n            yield fetchAndDecryptSecrets(options, recordsFilter);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n        }\r\n    }\r\n    return secrets;\r\n});\r\nconst updateSecret = (options, record) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const payload = yield prepareUpdatePayload(options.storage, record);\r\n    yield postQuery(options, 'update_secret', payload);\r\n});\r\nconst downloadFile = (file) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const fileResponse = yield exports.platform.get(file.url, {});\r\n    return exports.platform.decrypt(fileResponse.data, file.fileUid);\r\n});\r\nconst downloadThumbnail = (file) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const fileResponse = yield exports.platform.get(file.thumbnailUrl, {});\r\n    return exports.platform.decrypt(fileResponse.data, file.fileUid);\r\n});\n\nfunction getValue(secrets, notation) {\r\n    const schemaNotation = notation.split('://');\r\n    if (schemaNotation.length > 1) {\r\n        if (schemaNotation[0] !== 'keeper') {\r\n            throw Error(`Invalid notation schema: ${schemaNotation[0]}`);\r\n        }\r\n        notation = notation.slice(9);\r\n    }\r\n    const notationParts = notation.split('/');\r\n    if (notationParts.length < 3) {\r\n        throw Error(`Invalid notation ${notation}`);\r\n    }\r\n    const record = secrets.records.find(x => x.recordUid === notationParts[0]);\r\n    if (!record) {\r\n        throw Error(`Record ${notationParts[0]} not found`);\r\n    }\r\n    let fields;\r\n    switch (notationParts[1]) {\r\n        case 'field':\r\n            fields = record.data.fields;\r\n            break;\r\n        case 'custom_field':\r\n            fields = record.data.custom;\r\n            break;\r\n        case 'file':\r\n            const fileId = notationParts[2];\r\n            const file = (record.files || []).find(x => x.data.title === fileId || x.data.name === fileId);\r\n            if (!file) {\r\n                throw Error(`File ${fileId} not found in the record ${record.recordUid}`);\r\n            }\r\n            return file;\r\n        default:\r\n            throw Error(`Expected /field or /custom_field but found /${notationParts[1]}`);\r\n    }\r\n    const findField = (fieldName) => {\r\n        const field = fields.find(x => x.label === fieldName || x.type === fieldName);\r\n        if (!field) {\r\n            throw Error(`Field ${fieldName} not found in the record ${record.recordUid}`);\r\n        }\r\n        return field;\r\n    };\r\n    if (notationParts[2].endsWith('[]')) {\r\n        return findField(notationParts[2].slice(0, -2)).value;\r\n    }\r\n    const fieldParts = notationParts[2]\r\n        .replace(/[\\[\\]]/g, '/')\r\n        .split('/')\r\n        .filter(x => x);\r\n    const field = findField(fieldParts[0]);\r\n    if (fieldParts.length === 1) {\r\n        return field.value[0];\r\n    }\r\n    const fieldValueIdx = parseInt(fieldParts[1]);\r\n    if (isNaN(fieldValueIdx)) {\r\n        return field.value[0][fieldParts[1]];\r\n    }\r\n    if (fieldValueIdx < 0 || fieldValueIdx >= field.value.length) {\r\n        throw Error(`The index ${fieldValueIdx} for field value of ${fieldParts[0]} in the record ${record.recordUid} is out of range (${field.value.length - 1})`);\r\n    }\r\n    return fieldParts.length === 2\r\n        ? field.value[fieldValueIdx]\r\n        : field.value[fieldValueIdx][fieldParts[2]];\r\n}\n\nconst localConfigStorage = (configName) => {\r\n    const readStorage = () => {\r\n        if (!configName) {\r\n            return {};\r\n        }\r\n        try {\r\n            return JSON.parse(fs__namespace.readFileSync(configName).toString());\r\n        }\r\n        catch (e) {\r\n            return {};\r\n        }\r\n    };\r\n    const storageData = readStorage();\r\n    const storage = inMemoryStorage(storageData);\r\n    const saveStorage = (storage) => {\r\n        if (!configName) {\r\n            return;\r\n        }\r\n        fs__namespace.writeFileSync(configName, JSON.stringify(storageData, null, 2));\r\n    };\r\n    return {\r\n        getString: storage.getString,\r\n        saveString: (key, value) => __awaiter(void 0, void 0, void 0, function* () {\r\n            yield storage.saveString(key, value);\r\n            saveStorage();\r\n            return Promise.resolve();\r\n        }),\r\n        getBytes: storage.getBytes,\r\n        saveBytes: (key, value) => __awaiter(void 0, void 0, void 0, function* () {\r\n            yield storage.saveBytes(key, value);\r\n            saveStorage();\r\n            return Promise.resolve();\r\n        }),\r\n        delete: (key) => __awaiter(void 0, void 0, void 0, function* () {\r\n            yield storage.delete(key);\r\n            saveStorage();\r\n            return Promise.resolve();\r\n        })\r\n    };\r\n};\r\nconst cachingPostFunction = (url, transmissionKey, payload) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const response = yield exports.platform.post(url, payload.payload, {\r\n            PublicKeyId: transmissionKey.publicKeyId.toString(),\r\n            TransmissionKey: exports.platform.bytesToBase64(transmissionKey.encryptedKey),\r\n            Authorization: `Signature ${exports.platform.bytesToBase64(payload.signature)}`\r\n        });\r\n        if (response.statusCode == 200) {\r\n            fs__namespace.writeFileSync('cache.dat', Buffer.concat([transmissionKey.key, response.data]));\r\n        }\r\n        return response;\r\n    }\r\n    catch (e) {\r\n        let cachedData;\r\n        try {\r\n            cachedData = fs__namespace.readFileSync('cache.dat');\r\n        }\r\n        catch (_a) {\r\n        }\r\n        if (!cachedData) {\r\n            throw new Error('Cached value does not exist');\r\n        }\r\n        transmissionKey.key = cachedData.slice(0, 32);\r\n        return {\r\n            statusCode: 200,\r\n            data: cachedData.slice(32),\r\n            headers: []\r\n        };\r\n    }\r\n});\n\nconnectPlatform(nodePlatform);\r\ninitialize();\n\nexports.cachingPostFunction = cachingPostFunction;\nexports.connectPlatform = connectPlatform;\nexports.downloadFile = downloadFile;\nexports.downloadThumbnail = downloadThumbnail;\nexports.generateTransmissionKey = generateTransmissionKey;\nexports.getClientId = getClientId;\nexports.getSecrets = getSecrets;\nexports.getValue = getValue;\nexports.inMemoryStorage = inMemoryStorage;\nexports.initialize = initialize;\nexports.initializeStorage = initializeStorage;\nexports.loadJsonConfig = loadJsonConfig;\nexports.localConfigStorage = localConfigStorage;\nexports.updateSecret = updateSecret;\n//# sourceMappingURL=index.cjs.js.map\n","module.exports = require(\"crypto\");","module.exports = require(\"fs\");","module.exports = require(\"https\");","module.exports = require(\"os\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(109);\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;ACrSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACjrBA;;A;;;;;ACAA;;A;;;;;ACAA;;A;;;;;ACAA;;A;;;;;ACAA;;A;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;ACDA;AACA;AACA;AACA;;;;A","sourceRoot":""}